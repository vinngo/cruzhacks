---
phase: 03-guidance-annotations
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - components/workspace/AnnotationOverlay.tsx
  - components/workspace/CanvasPanel.tsx
  - components/TldrawEditor.tsx
  - lib/problem-context.tsx
autonomous: false

must_haves:
  truths:
    - "User can approve annotation to add it permanently to canvas"
    - "Approved annotation renders as tldraw text shape on canvas"
    - "User can dismiss annotation to remove it without adding to canvas"
    - "Dismissed annotation leaves no trace (not in state or on canvas)"
    - "Complete demo flow works: problem → canvas work → AI guidance → annotation → solve"
  artifacts:
    - path: "components/workspace/AnnotationOverlay.tsx"
      provides: "Approve handler that adds shape to canvas and stores overlay positions"
      contains: "createShape.*text.*storedPositions"
    - path: "components/TldrawEditor.tsx"
      provides: "addAnnotationToCanvas method exposed via ref"
      exports: ["TldrawEditorRef"]
      contains: "createShape"
    - path: "components/workspace/CanvasPanel.tsx"
      provides: "Wiring between overlay approve and tldraw shape creation"
      contains: "addAnnotationToCanvas"
    - path: "lib/problem-context.tsx"
      provides: "Store screen positions for approve reuse"
      contains: "annotationPositions"
  key_links:
    - from: "components/workspace/AnnotationOverlay.tsx"
      to: "components/TldrawEditor.tsx"
      via: "editorRef.addAnnotationToCanvas() on approve with stored screen position"
      pattern: "addAnnotationToCanvas.*storedPosition"
    - from: "components/TldrawEditor.tsx"
      to: "tldraw createShape API"
      via: "editor.createShape with text type and screenToPage conversion"
      pattern: "createShape.*screenToPage"
---

<objective>
Wire annotation approve action to add text shapes to canvas via tldraw API with coordinate conversion, and verify complete demo flow.

Purpose: Complete the annotation system by implementing the approve action that adds annotations as permanent canvas shapes with correct coordinate transformation from screen to page space, and verify the full user journey from problem submission to AI-guided problem solving. Achieves Phase 3's goal: interactive canvas annotations that guide learning.

Output: Working approve/dismiss handlers with stored overlay positions, tldraw integration for adding text shapes with screenToPage conversion, verified end-to-end demo flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-guidance-annotations/03-01-SUMMARY.md
@.planning/phases/03-guidance-annotations/03-02-SUMMARY.md

# Files to modify
@components/workspace/AnnotationOverlay.tsx
@components/TldrawEditor.tsx
@components/workspace/CanvasPanel.tsx
@lib/annotation-positioning.ts
@lib/problem-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Implement approve handler with tldraw shape creation and coordinate conversion</name>
  <files>components/TldrawEditor.tsx, components/workspace/AnnotationOverlay.tsx, lib/problem-context.tsx</files>
  <action>
**Update lib/problem-context.tsx:**
Store screen positions for reuse on approve:

```typescript
import { AnnotationPosition } from './annotation-positioning';

export type ProblemContextType = {
  // ... existing fields
  proposedAnnotations: ProposedAnnotation[];
  annotationPositions: Map<string, AnnotationPosition>; // Map annotation ID to screen position
  addProposedAnnotation: (annotation: ProposedAnnotation) => void;
  removeProposedAnnotation: (id: string) => void;
  clearProposedAnnotations: () => void;
  setAnnotationPosition: (id: string, position: AnnotationPosition) => void;
};

// In ProblemProvider:
const [annotationPositions, setAnnotationPositions] = useState<Map<string, AnnotationPosition>>(new Map());

const setAnnotationPosition = (id: string, position: AnnotationPosition) => {
  setAnnotationPositions(prev => new Map(prev).set(id, position));
};

const removeProposedAnnotation = (id: string) => {
  setProposedAnnotations(prev => prev.filter(a => a.id !== id));
  setAnnotationPositions(prev => {
    const updated = new Map(prev);
    updated.delete(id);
    return updated;
  });
};
```

**Update TldrawEditor.tsx:**
Add method to create text shapes from annotations with screen-to-page conversion:

```typescript
import { createShapeId } from 'tldraw';

export interface TldrawEditorRef {
  captureScreenshot: () => Promise<string[] | null>;
  getEditor: () => Editor | null;
  addAnnotationToCanvas: (text: string, screenPosition: { x: number; y: number }, color: string) => void;
}

// In useImperativeHandle:
useImperativeHandle(ref, () => ({
  captureScreenshot: async () => { /* existing */ },
  getEditor: () => editorRef.current,
  addAnnotationToCanvas: (text: string, screenPosition: { x: number; y: number }, color: string) => {
    if (!editorRef.current) {
      console.warn('Editor not mounted yet');
      return;
    }

    // CRITICAL: Convert screen coordinates to page coordinates
    // calculateAnnotationPosition returns screen pixels, but createShape expects page coordinates
    const pagePosition = editorRef.current.screenToPage(screenPosition);

    const shapeId = createShapeId();

    editorRef.current.createShape({
      id: shapeId,
      type: 'text',
      x: pagePosition.x,
      y: pagePosition.y,
      props: {
        text,
        color, // 'blue' for questions, 'yellow' for hints (tldraw colors)
        size: 'm',
        font: 'sans',
        textAlign: 'start',
        w: 250, // Width of text box
      },
    });

    // Optional: Select the new shape to draw attention
    editorRef.current.select(shapeId);
  },
}));
```

**Update AnnotationOverlay.tsx:**
Store overlay positions and reuse on approve (avoid recalculation drift):

```typescript
import { useProblem } from '@/lib/problem-context';
import { calculateAnnotationPosition, AnnotationPosition } from '@/lib/annotation-positioning';
import { useEffect, useMemo } from 'react';

export function AnnotationOverlay({ editorRef }: AnnotationOverlayProps) {
  const {
    proposedAnnotations,
    removeProposedAnnotation,
    annotationPositions,
    setAnnotationPosition,
  } = useProblem();

  // Calculate positions for all annotations using smart positioning
  const calculatedPositions = useMemo(() => {
    const editor = editorRef.current?.getEditor() || null;
    const positions: AnnotationPosition[] = [];

    proposedAnnotations.forEach(annotation => {
      const position = calculateAnnotationPosition(editor, annotation, positions);
      positions.push(position);
    });

    return positions;
  }, [proposedAnnotations]);

  // Store calculated positions in context for approve reuse
  useEffect(() => {
    proposedAnnotations.forEach((annotation, index) => {
      if (!annotationPositions.has(annotation.id)) {
        setAnnotationPosition(annotation.id, calculatedPositions[index]);
      }
    });
  }, [proposedAnnotations, calculatedPositions, annotationPositions, setAnnotationPosition]);

  const handleApprove = (annotation: ProposedAnnotation) => {
    if (!editorRef.current) {
      console.warn('Editor ref not available');
      return;
    }

    // Retrieve stored screen position (avoid recalculation drift)
    const storedPosition = annotationPositions.get(annotation.id);
    if (!storedPosition) {
      console.warn('No stored position for annotation:', annotation.id);
      return;
    }

    // Convert annotation type to tldraw color
    const color = annotation.type === 'question' ? 'blue' : 'yellow';

    // Add to canvas as text shape (addAnnotationToCanvas handles screen-to-page conversion)
    editorRef.current.addAnnotationToCanvas(annotation.text, storedPosition, color);

    // Remove from proposed annotations (also removes from annotationPositions map)
    removeProposedAnnotation(annotation.id);
  };

  const handleDismiss = (id: string) => {
    // Simply remove from state - no trace left
    removeProposedAnnotation(id);
  };

  return (
    <>
      {proposedAnnotations.map((annotation, index) => {
        const position = annotationPositions.get(annotation.id) || calculatedPositions[index];
        return (
          <AnnotationCard
            key={annotation.id}
            annotation={annotation}
            onApprove={() => handleApprove(annotation)}
            onDismiss={() => handleDismiss(annotation.id)}
            position={position}
          />
        );
      })}
    </>
  );
}
```

**Update AnnotationCard component signature:**
```typescript
interface AnnotationCardProps {
  annotation: ProposedAnnotation;
  onApprove: () => void; // Changed from (id: string) => void
  onDismiss: () => void; // Changed from (id: string) => void
  position: AnnotationPosition;
}

function AnnotationCard({ annotation, onApprove, onDismiss, position }: AnnotationCardProps) {
  const isQuestion = annotation.type === 'question';

  return (
    <div
      className={cn(
        "absolute z-10 w-70 p-4 rounded-lg shadow-lg border-2 backdrop-blur-sm",
        isQuestion
          ? "bg-blue-50/95 border-blue-400"
          : "bg-amber-50/95 border-amber-400"
      )}
      style={{
        left: `${position.x}px`,
        top: `${position.y}px`,
      }}
    >
      <div className="mb-3">
        <span className={cn(
          "text-xs font-semibold uppercase tracking-wide",
          isQuestion ? "text-blue-700" : "text-amber-700"
        )}>
          {isQuestion ? "Question" : "Hint"}
        </span>
        <p className="mt-1 text-sm text-gray-800 leading-relaxed">
          {annotation.text}
        </p>
      </div>

      <div className="flex gap-2">
        <button
          onClick={onApprove} // No ID needed, closure handles it
          className="flex-1 flex items-center justify-center gap-1 px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded transition-colors"
        >
          <CheckIcon className="w-4 h-4" />
          Approve
        </button>
        <button
          onClick={onDismiss} // No ID needed, closure handles it
          className="flex-1 flex items-center justify-center gap-1 px-3 py-1.5 bg-gray-600 hover:bg-gray-700 text-white text-sm font-medium rounded transition-colors"
        >
          <XIcon className="w-4 h-4" />
          Dismiss
        </button>
      </div>
    </div>
  );
}
```

**Implementation notes:**
- tldraw text shape props: https://tldraw.dev/docs/shapes#text-shape
- Color options: 'black', 'grey', 'light-violet', 'violet', 'blue', 'light-blue', 'yellow', 'orange', 'green', 'light-green', 'light-red', 'red'
- Use 'blue' for questions (Socratic), 'yellow' for hints (caution/attention)
- Text box width (w: 250) allows wrapping for longer annotations
- CRITICAL: calculateAnnotationPosition returns SCREEN coordinates (pixels from viewport edge)
- CRITICAL: createShape expects PAGE coordinates (canvas space)
- CRITICAL: Use editor.screenToPage() to convert before creating shape
- Store overlay positions in context to avoid recalculation on approve (prevents position drift)
- createShapeId() generates unique ID for shape
  </action>
  <verify>
    AI proposes annotation → AnnotationCard appears
    Click "Approve" → text shape appears on canvas at correct position
    Text shape position matches overlay card position (no drift)
    Text shape contains annotation text
    Question annotations appear in blue
    Hint annotations appear in yellow
    Approved annotation disappears from overlay
    Click "Dismiss" → annotation disappears, no shape added
    Dismissed annotation leaves no trace (not in state, not on canvas)
    Multiple approve/dismiss actions work correctly
    Coordinate conversion correct (screen to page via screenToPage)
    Build passes: npm run build
  </verify>
  <done>Approve adds annotation as tldraw text shape with correct coordinate conversion, stored overlay positions prevent drift, dismiss removes cleanly, both update proposedAnnotations state correctly</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete AI-guided annotation system:
- Collapsible chat sidebar (Phase 3 Plan 1)
- AI structured annotation proposals via tool calling (Phase 3 Plan 1)
- Annotation overlay UI with approve/dismiss buttons (Phase 3 Plan 2)
- Smart positioning avoiding viewport edges (Phase 3 Plan 2)
- Approve handler adding annotations to canvas as tldraw shapes with coordinate conversion (Phase 3 Plan 3)
- Stored overlay positions preventing position drift on approve (Phase 3 Plan 3)
- Dismiss handler removing annotations without trace (Phase 3 Plan 3)
  </what-built>
  <how-to-verify>
**Complete demo flow (Success Criteria 7 from Phase 3):**

1. **Start fresh:**
   - Open http://localhost:3000
   - Clear localStorage: `localStorage.clear()` in console
   - Refresh page

2. **Submit problem:**
   - Enter math problem (text or upload image): "Solve for x: 2x + 5 = 15"
   - Click submit → transition to workspace
   - Verify: Problem displays in left panel
   - Verify: AI sends initial greeting in chat

3. **Work on canvas:**
   - Draw or write on canvas (start solving the problem)
   - Example: Write "2x + 5 = 15" on canvas
   - Pause for 4 seconds
   - Verify: Chat shows "Analyzing canvas..."
   - Verify: AI responds with Socratic question OR proposes annotation

4. **Interact with annotations:**
   - If AI proposes annotation:
     - Verify: Annotation card appears overlaid on canvas
     - Verify: Question type → blue theme, Hint type → amber theme
     - Verify: Card includes approve/dismiss buttons
     - Click "Approve" → annotation added to canvas as text shape
     - Verify: Annotation text appears on canvas (blue for question, yellow for hint)
     - Verify: Canvas text shape position matches overlay card position (no drift)
     - Verify: Approved annotation removed from overlay
   - If AI proposes another annotation:
     - Click "Dismiss" → annotation disappears
     - Verify: No shape added to canvas
     - Verify: Dismissed annotation not in overlay or state

5. **Test collapsible chat:**
   - Click chevron button in chat header
   - Verify: Chat collapses to ~48px width with smooth animation
   - Verify: Canvas expands to fill space
   - Click chevron again
   - Verify: Chat expands back to ~320px

6. **Continue solving:**
   - Add more work to canvas
   - Continue conversation with AI
   - Verify: AI references both canvas work and chat history
   - Verify: Multiple annotations can exist simultaneously
   - Verify: Annotations positioned to avoid overlapping each other

7. **Final verification:**
   - All Phase 3 requirements met (see checklist below)
   - No console errors
   - Smooth transitions and interactions
   - Professional appearance and UX

**Phase 3 Requirements Checklist:**

- [ ] AI-05: User receives AI's Socratic questions in chat sidebar ✓
- [ ] WORK-03: Collapsible chat sidebar ✓
- [ ] ANNO-01: AI proposes text question annotations ✓
- [ ] ANNO-02: AI proposes hint/scaffolding annotations ✓
- [ ] ANNO-03: Annotations have approve/dismiss buttons ✓
- [ ] ANNO-04: Annotations positioned to avoid overlaps ✓
- [ ] ANNO-05: Approve adds annotation to canvas via tldraw ✓
- [ ] ANNO-06: Dismiss removes annotation without trace ✓

**Coordinate conversion verification:**

- [ ] Overlay card position matches canvas text shape position exactly
- [ ] No drift or offset when approving annotation
- [ ] Screen coordinates correctly converted to page coordinates

**Common issues to check:**

- Annotations not appearing: Check console for tool call extraction errors
- Annotations appear in wrong position on canvas: Verify screenToPage conversion
- Overlay position differs from canvas position: Check stored positions reuse
- Approve doesn't add to canvas: Check editorRef and createShape call
- Chat not collapsing smoothly: Verify transition-all CSS class
- AI not proposing annotations: Check system prompt guidance in route.ts

**If any issues found:**
Document them clearly:
- What action was taken
- What happened (actual result)
- What should happen (expected result)
- Console errors (if any)
- Screenshots (if visual issue)
  </how-to-verify>
  <resume-signal>
Type "approved" if demo flow works end-to-end, or describe specific issues to address.
  </resume-signal>
</task>

</tasks>

<verification>
**Approve handler:**
1. Clicking approve creates tldraw text shape on canvas
2. Text shape contains annotation text
3. Question annotations render in blue
4. Hint annotations render in yellow
5. Approved annotation removed from overlay
6. Canvas shape position matches overlay card position (stored positions prevent drift)
7. Screen coordinates correctly converted to page coordinates via screenToPage

**Dismiss handler:**
1. Clicking dismiss removes annotation from overlay
2. No shape added to canvas
3. No trace in proposedAnnotations state
4. No trace in annotationPositions map

**End-to-end demo flow:**
1. User submits problem → workspace loads
2. User works on canvas → AI analyzes and responds
3. AI proposes annotations via tool calling
4. Annotations appear as overlays with approve/dismiss
5. User approves → annotation added to canvas at correct position
6. User dismisses → annotation removed cleanly
7. User continues solving with AI guidance

**Technical checks:**
- Build passes: `npm run build`
- No console errors during full flow
- tldraw createShape API called correctly
- Coordinate conversion correct (screen to page via screenToPage)
- Stored positions prevent recalculation drift
- State management clean (no memory leaks)

**Requirements coverage:**
- AI-05: Socratic questions in chat ✓
- WORK-03: Collapsible chat sidebar ✓
- ANNO-01: Text question annotations ✓
- ANNO-02: Hint/scaffolding annotations ✓
- ANNO-03: Approve/dismiss buttons ✓
- ANNO-04: Smart positioning ✓
- ANNO-05: Approve adds to canvas with correct coordinates ✓
- ANNO-06: Dismiss removes without trace ✓
</verification>

<success_criteria>
- [ ] Approve button adds annotation as tldraw text shape on canvas
- [ ] Screen coordinates converted to page coordinates via editor.screenToPage()
- [ ] Stored overlay positions reused on approve (no recalculation drift)
- [ ] Canvas text shape position matches overlay card position exactly
- [ ] Question annotations render in blue on canvas
- [ ] Hint annotations render in yellow on canvas
- [ ] Approved annotations removed from overlay
- [ ] Dismiss button removes annotation without adding to canvas
- [ ] Dismissed annotations leave no trace in state or position map
- [ ] Complete demo flow verified by user
- [ ] All Phase 3 requirements met
- [ ] Build passes without errors
- [ ] User approves checkpoint (no blocking issues)
</success_criteria>

<output>
After completion, create `.planning/phases/03-guidance-annotations/03-03-SUMMARY.md`
</output>
