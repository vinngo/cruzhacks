---
phase: 03-guidance-annotations
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - components/workspace/AnnotationOverlay.tsx
  - lib/annotation-positioning.ts
  - components/workspace/CanvasPanel.tsx
  - lib/problem-context.tsx
autonomous: true

must_haves:
  truths:
    - "Proposed annotations appear as overlays on canvas with approve/dismiss buttons"
    - "Annotations positioned to avoid overlapping user's existing canvas work"
    - "Question annotations styled distinctly from hint annotations"
    - "Approve/dismiss buttons respond to clicks"
    - "Multiple annotations can be displayed simultaneously"
  artifacts:
    - path: "components/workspace/AnnotationOverlay.tsx"
      provides: "Rendered annotation cards with approve/dismiss buttons"
      min_lines: 80
      contains: "ProposedAnnotation.*approve.*dismiss"
    - path: "lib/annotation-positioning.ts"
      provides: "Smart positioning algorithm avoiding overlaps"
      exports: ["calculateAnnotationPosition"]
      min_lines: 40
    - path: "components/workspace/CanvasPanel.tsx"
      provides: "Annotation overlay integration with canvas"
      contains: "AnnotationOverlay"
    - path: "lib/problem-context.tsx"
      provides: "Shared annotation state across workspace"
      contains: "proposedAnnotations.*setProposedAnnotations"
  key_links:
    - from: "components/workspace/ChatPanel.tsx"
      to: "lib/problem-context.tsx"
      via: "Tool calls extracted and stored as proposedAnnotations"
      pattern: "setProposedAnnotations"
    - from: "components/workspace/AnnotationOverlay.tsx"
      to: "lib/annotation-positioning.ts"
      via: "Calculate position for each annotation"
      pattern: "calculateAnnotationPosition"
    - from: "components/workspace/CanvasPanel.tsx"
      to: "components/workspace/AnnotationOverlay.tsx"
      via: "Render overlay on top of tldraw canvas"
      pattern: "AnnotationOverlay"
---

<objective>
Render AI-proposed annotations as interactive overlays on canvas with smart positioning.

Purpose: Visualize AI's annotation proposals on the canvas itself (not just in chat) with approve/dismiss controls, positioned intelligently to avoid overlapping student's work. Completes the annotation UI foundation before canvas integration.

Output: Annotation overlay component displaying proposed annotations with styling, approve/dismiss buttons, smart positioning algorithm that avoids canvas shapes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-guidance-annotations/03-01-SUMMARY.md

# Files to reference
@lib/types/annotations.ts
@components/workspace/CanvasPanel.tsx
@lib/problem-context.tsx
@components/TldrawEditor.tsx
</context>

<tasks>

<task type="auto">
  <name>Extract annotation proposals from AI responses and store in context</name>
  <files>lib/problem-context.tsx, components/workspace/ChatPanel.tsx</files>
  <action>
**Extend ProblemContext (lib/problem-context.tsx):**
Add annotation state management:

```typescript
import { ProposedAnnotation } from './types/annotations';

export type ProblemContextType = {
  // ... existing fields
  proposedAnnotations: ProposedAnnotation[];
  addProposedAnnotation: (annotation: ProposedAnnotation) => void;
  removeProposedAnnotation: (id: string) => void;
  clearProposedAnnotations: () => void;
};

// In ProblemProvider:
const [proposedAnnotations, setProposedAnnotations] = useState<ProposedAnnotation[]>([]);

const addProposedAnnotation = (annotation: ProposedAnnotation) => {
  setProposedAnnotations(prev => [...prev, annotation]);
};

const removeProposedAnnotation = (id: string) => {
  setProposedAnnotations(prev => prev.filter(a => a.id !== id));
};

const clearProposedAnnotations = () => {
  setProposedAnnotations([]);
};
```

**Update ChatPanel (components/workspace/ChatPanel.tsx):**
Extract tool calls from AI responses:

```typescript
import { addProposedAnnotation } from context;
import { v4 as uuidv4 } from 'uuid'; // OR: crypto.randomUUID()

// Monitor messages for tool calls
useEffect(() => {
  messages.forEach(message => {
    if (message.role === 'assistant' && message.parts) {
      message.parts.forEach(part => {
        if (part.type === 'tool-call' && part.toolName === 'proposeAnnotation') {
          const { type, text, positionHint } = part.args;
          const annotation: ProposedAnnotation = {
            id: crypto.randomUUID(),
            type,
            text,
            positionHint, // Will be converted to actual x/y by positioning algorithm
          };
          addProposedAnnotation(annotation);
        }
      });
    }
  });
}, [messages]);
```

**Important:** AI SDK useChat hook includes tool calls in messages.parts array. Check part.type === 'tool-call' and part.toolName === 'proposeAnnotation'.

If crypto.randomUUID() not available in browser context, use fallback: `${Date.now()}-${Math.random()}`.
  </action>
  <verify>
    Send message with canvas screenshot → AI proposes annotation via tool call
    Console.log shows tool call extracted from messages array
    proposedAnnotations state in context updated with new annotation
    Annotation has unique ID, type, text fields
    Multiple annotations accumulate in state (don't overwrite)
  </verify>
  <done>AI tool calls extracted from chat responses and stored as proposedAnnotations in React context</done>
</task>

<task type="auto">
  <name>Create annotation overlay component with approve/dismiss UI</name>
  <files>components/workspace/AnnotationOverlay.tsx, lib/annotation-positioning.ts, components/workspace/CanvasPanel.tsx</files>
  <action>
**Create lib/annotation-positioning.ts:**
Smart positioning algorithm that avoids canvas shapes:

```typescript
import { Editor } from 'tldraw';
import { ProposedAnnotation } from './types/annotations';

export interface AnnotationPosition {
  x: number; // pixels from left
  y: number; // pixels from top
}

/**
 * Calculate annotation position avoiding canvas shapes
 * Strategy: Use positionHint as preference, check for overlaps, fallback to safe zones
 */
export function calculateAnnotationPosition(
  editor: Editor,
  annotation: ProposedAnnotation,
  annotationWidth: number = 280, // Estimated annotation card width
  annotationHeight: number = 100, // Estimated annotation card height
): AnnotationPosition {
  const { positionHint = 'top-right' } = annotation;

  // Get canvas viewport bounds
  const viewportPageBounds = editor.getViewportPageBounds();
  const canvasBounds = {
    width: viewportPageBounds.width,
    height: viewportPageBounds.height,
  };

  // Get all shapes to avoid
  const allShapes = Array.from(editor.getCurrentPageShapeIds());
  const shapeBounds = allShapes.map(id => editor.getShapePageBounds(id)).filter(Boolean);

  // Define candidate positions based on hint
  const candidates = getPositionCandidates(positionHint, canvasBounds, annotationWidth, annotationHeight);

  // Find first non-overlapping position
  for (const candidate of candidates) {
    if (!overlapsAnyShape(candidate, annotationWidth, annotationHeight, shapeBounds)) {
      return candidate;
    }
  }

  // Fallback: top-right corner (least likely to interfere)
  return { x: canvasBounds.width - annotationWidth - 20, y: 20 };
}

function getPositionCandidates(
  hint: string,
  canvasBounds: { width: number; height: number },
  w: number,
  h: number,
): AnnotationPosition[] {
  const padding = 20;
  const positions: Record<string, AnnotationPosition> = {
    'top-left': { x: padding, y: padding },
    'top-right': { x: canvasBounds.width - w - padding, y: padding },
    'bottom-left': { x: padding, y: canvasBounds.height - h - padding },
    'bottom-right': { x: canvasBounds.width - w - padding, y: canvasBounds.height - h - padding },
    'center': { x: canvasBounds.width / 2 - w / 2, y: canvasBounds.height / 2 - h / 2 },
  };

  const preferred = positions[hint];

  // Return preferred position first, then other corners as fallbacks
  return [
    preferred,
    positions['top-right'],
    positions['top-left'],
    positions['bottom-right'],
    positions['bottom-left'],
  ].filter(Boolean);
}

function overlapsAnyShape(
  pos: AnnotationPosition,
  w: number,
  h: number,
  shapeBounds: any[],
): boolean {
  const annotationBox = {
    minX: pos.x,
    minY: pos.y,
    maxX: pos.x + w,
    maxY: pos.y + h,
  };

  return shapeBounds.some(shapeBound => {
    if (!shapeBound) return false;
    return !(
      annotationBox.maxX < shapeBound.minX ||
      annotationBox.minX > shapeBound.maxX ||
      annotationBox.maxY < shapeBound.minY ||
      annotationBox.minY > shapeBound.maxY
    );
  });
}
```

**Create components/workspace/AnnotationOverlay.tsx:**
Render annotations as positioned overlays:

```tsx
"use client";

import { useProblem } from '@/lib/problem-context';
import { ProposedAnnotation } from '@/lib/types/annotations';
import { CheckIcon, XIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

interface AnnotationCardProps {
  annotation: ProposedAnnotation;
  onApprove: (id: string) => void;
  onDismiss: (id: string) => void;
  style?: React.CSSProperties;
}

function AnnotationCard({ annotation, onApprove, onDismiss, style }: AnnotationCardProps) {
  const isQuestion = annotation.type === 'question';

  return (
    <div
      className={cn(
        "absolute z-10 w-70 p-4 rounded-lg shadow-lg border-2 backdrop-blur-sm",
        isQuestion
          ? "bg-blue-50/95 border-blue-400"
          : "bg-amber-50/95 border-amber-400"
      )}
      style={style}
    >
      <div className="mb-3">
        <span className={cn(
          "text-xs font-semibold uppercase tracking-wide",
          isQuestion ? "text-blue-700" : "text-amber-700"
        )}>
          {isQuestion ? "Question" : "Hint"}
        </span>
        <p className="mt-1 text-sm text-gray-800 leading-relaxed">
          {annotation.text}
        </p>
      </div>

      <div className="flex gap-2">
        <button
          onClick={() => onApprove(annotation.id)}
          className="flex-1 flex items-center justify-center gap-1 px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded transition-colors"
        >
          <CheckIcon className="w-4 h-4" />
          Approve
        </button>
        <button
          onClick={() => onDismiss(annotation.id)}
          className="flex-1 flex items-center justify-center gap-1 px-3 py-1.5 bg-gray-600 hover:bg-gray-700 text-white text-sm font-medium rounded transition-colors"
        >
          <XIcon className="w-4 h-4" />
          Dismiss
        </button>
      </div>
    </div>
  );
}

interface AnnotationOverlayProps {
  editorRef: React.RefObject<any>; // TldrawEditorRef from parent
}

export function AnnotationOverlay({ editorRef }: AnnotationOverlayProps) {
  const { proposedAnnotations, removeProposedAnnotation } = useProblem();

  const handleApprove = (id: string) => {
    // Will be implemented in next plan (canvas integration)
    console.log('Approve annotation:', id);
    // For now, just remove from proposed list
    removeProposedAnnotation(id);
  };

  const handleDismiss = (id: string) => {
    removeProposedAnnotation(id);
  };

  // Position annotations will be calculated in next iteration
  // For now, use simple stacking with offset
  return (
    <>
      {proposedAnnotations.map((annotation, index) => (
        <AnnotationCard
          key={annotation.id}
          annotation={annotation}
          onApprove={handleApprove}
          onDismiss={handleDismiss}
          style={{
            top: 20 + (index * 120), // Stack vertically with 120px spacing
            right: 20,
          }}
        />
      ))}
    </>
  );
}
```

**Update components/workspace/CanvasPanel.tsx:**
Integrate annotation overlay:

```tsx
import { AnnotationOverlay } from './AnnotationOverlay';

// In CanvasPanel component:
return (
  <div className="relative w-full h-full">
    <TldrawEditor ref={editorRef} onChange={handleCanvasChange} />
    <AnnotationOverlay editorRef={editorRef} />
  </div>
);
```

**Styling notes:**
- Questions: Blue theme (bg-blue-50/95, border-blue-400) for Socratic questions
- Hints: Amber theme (bg-amber-50/95, border-amber-400) for scaffolding
- Semi-transparent backdrop-blur for visibility over canvas
- z-10 ensures overlays appear above canvas
- Fixed width (w-70 = 280px) for consistent sizing
- Simple vertical stacking for now (smart positioning via algorithm in refinement)

**Positioning strategy:**
- Initial: Simple stacking (top-right, 20px from edge, 120px vertical spacing)
- Refinement: Use calculateAnnotationPosition() from positioning util
- Algorithm considers canvas shape bounds to avoid overlaps
  </action>
  <verify>
    AI proposes annotation → AnnotationCard appears overlaid on canvas
    Question annotations styled with blue theme
    Hint annotations styled with amber theme
    Approve button clickable → removes annotation from view
    Dismiss button clickable → removes annotation from view
    Multiple annotations stack vertically without overlap
    Annotations visible above canvas (z-index works)
    Semi-transparent background readable over canvas content
    Build passes with no TypeScript errors
  </verify>
  <done>Annotations render as overlays with approve/dismiss buttons, distinct question/hint styling, smart positioning avoiding canvas shapes</done>
</task>

</tasks>

<verification>
**Annotation overlay:**
1. AI-proposed annotations appear as cards overlaid on canvas
2. Cards include type indicator (Question/Hint), text, approve/dismiss buttons
3. Question annotations: blue theme
4. Hint annotations: amber theme
5. Cards semi-transparent with backdrop blur

**Positioning:**
1. Annotations positioned in top-right by default
2. Multiple annotations stack vertically without overlap
3. Positioning algorithm calculates positions avoiding canvas shapes
4. Falls back to safe corner if all positions overlap

**Interactions:**
1. Approve button removes annotation (placeholder for canvas integration)
2. Dismiss button removes annotation completely
3. Buttons respond to clicks with visual feedback

**Technical checks:**
- Build passes: `npm run build`
- No console errors during annotation rendering
- proposedAnnotations state updates correctly in context
- Tool calls from AI successfully converted to annotation cards

**Requirements coverage:**
- ANNO-03: Approve/dismiss buttons on annotations ✓
- ANNO-04: Smart positioning avoiding overlaps ✓
- ANNO-06: Dismiss removes without trace ✓ (partial - full in next plan)
</verification>

<success_criteria>
- [ ] AI tool calls extracted from chat messages and stored in context
- [ ] Annotation cards render overlaid on canvas
- [ ] Question annotations styled with blue theme
- [ ] Hint annotations styled with amber theme
- [ ] Approve and dismiss buttons functional
- [ ] Positioning algorithm avoids overlapping canvas shapes
- [ ] Multiple annotations display simultaneously without overlap
- [ ] Dismiss removes annotation from view immediately
- [ ] Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-guidance-annotations/03-02-SUMMARY.md`
</output>
