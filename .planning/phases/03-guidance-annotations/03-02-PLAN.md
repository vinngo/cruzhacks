---
phase: 03-guidance-annotations
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - components/workspace/AnnotationOverlay.tsx
  - lib/annotation-positioning.ts
  - components/workspace/CanvasPanel.tsx
  - lib/problem-context.tsx
  - components/workspace/ChatPanel.tsx
autonomous: true

must_haves:
  truths:
    - "Proposed annotations appear as overlays on canvas with approve/dismiss buttons"
    - "Annotations positioned using smart algorithm that considers canvas viewport"
    - "Question annotations styled distinctly from hint annotations"
    - "Approve/dismiss buttons respond to clicks"
    - "Multiple annotations can be displayed simultaneously"
  artifacts:
    - path: "components/workspace/AnnotationOverlay.tsx"
      provides: "Rendered annotation cards with approve/dismiss buttons and smart positioning"
      min_lines: 80
      contains: "ProposedAnnotation.*approve.*dismiss.*calculateAnnotationPosition"
    - path: "lib/annotation-positioning.ts"
      provides: "Smart positioning algorithm using canvas viewport"
      exports: ["calculateAnnotationPosition"]
      min_lines: 40
    - path: "components/workspace/CanvasPanel.tsx"
      provides: "Annotation overlay integration with canvas"
      contains: "AnnotationOverlay"
    - path: "lib/problem-context.tsx"
      provides: "Shared annotation state across workspace"
      contains: "proposedAnnotations.*setProposedAnnotations"
    - path: "components/workspace/ChatPanel.tsx"
      provides: "Tool call extraction with duplicate prevention"
      contains: "processedMessageIds|tool-call"
  key_links:
    - from: "components/workspace/ChatPanel.tsx"
      to: "lib/problem-context.tsx"
      via: "Tool calls extracted from message.parts and stored as proposedAnnotations"
      pattern: "part\\.type.*tool-call.*addProposedAnnotation"
    - from: "components/workspace/AnnotationOverlay.tsx"
      to: "lib/annotation-positioning.ts"
      via: "Calculate position for each annotation using editor instance"
      pattern: "calculateAnnotationPosition.*getEditor"
    - from: "components/workspace/CanvasPanel.tsx"
      to: "components/workspace/AnnotationOverlay.tsx"
      via: "Render overlay on top of tldraw canvas with editor ref"
      pattern: "AnnotationOverlay.*editorRef"
---

<objective>
Render AI-proposed annotations as interactive overlays on canvas with smart positioning.

Purpose: Visualize AI's annotation proposals on the canvas itself (not just in chat) with approve/dismiss controls, positioned intelligently using viewport bounds. Implements tool call extraction from AI SDK with duplicate prevention and complete annotation UI.

Output: Annotation overlay component displaying proposed annotations with styling, approve/dismiss buttons, smart positioning algorithm using canvas viewport, tool call extraction with duplicate tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-guidance-annotations/03-01-SUMMARY.md

# Files to reference
@lib/types/annotations.ts
@components/workspace/CanvasPanel.tsx
@lib/problem-context.tsx
@components/TldrawEditor.tsx
@components/workspace/ChatPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Extract annotation proposals from AI responses with duplicate prevention</name>
  <files>lib/problem-context.tsx, components/workspace/ChatPanel.tsx</files>
  <action>
**Extend ProblemContext (lib/problem-context.tsx):**
Add annotation state management:

```typescript
import { ProposedAnnotation } from './types/annotations';

export type ProblemContextType = {
  // ... existing fields
  proposedAnnotations: ProposedAnnotation[];
  addProposedAnnotation: (annotation: ProposedAnnotation) => void;
  removeProposedAnnotation: (id: string) => void;
  clearProposedAnnotations: () => void;
};

// In ProblemProvider:
const [proposedAnnotations, setProposedAnnotations] = useState<ProposedAnnotation[]>([]);

const addProposedAnnotation = (annotation: ProposedAnnotation) => {
  setProposedAnnotations(prev => [...prev, annotation]);
};

const removeProposedAnnotation = (id: string) => {
  setProposedAnnotations(prev => prev.filter(a => a.id !== id));
};

const clearProposedAnnotations = () => {
  setProposedAnnotations([]);
};
```

**Update ChatPanel (components/workspace/ChatPanel.tsx):**
Extract tool calls from AI SDK message.parts array with duplicate prevention:

```typescript
import { useProblem } from '@/lib/problem-context';
import { useRef } from 'react';

// Add near other refs
const processedMessageIdsRef = useRef<Set<string>>(new Set());

const { addProposedAnnotation } = useProblem();

// Monitor messages for tool calls with duplicate prevention
useEffect(() => {
  messages.forEach(message => {
    // Skip if already processed this message
    if (processedMessageIdsRef.current.has(message.id)) {
      return;
    }

    if (message.role === 'assistant' && message.parts) {
      message.parts.forEach(part => {
        // AI SDK useChat hook returns tool calls with part.type === 'tool-call'
        if (part.type === 'tool-call' && part.toolName === 'proposeAnnotation') {
          const { type, text, positionHint } = part.args;
          const annotation: ProposedAnnotation = {
            id: crypto.randomUUID(), // Unique ID for each annotation
            type,
            text,
            positionHint,
          };
          addProposedAnnotation(annotation);
        }
      });

      // Mark message as processed
      processedMessageIdsRef.current.add(message.id);
    }
  });
}, [messages, addProposedAnnotation]);
```

**Important notes:**
- AI SDK's `useChat` hook returns messages with `message.parts` array
- Each part has `part.type` which can be 'text' or 'tool-call'
- Tool calls have `part.toolName` (e.g., 'proposeAnnotation') and `part.args` (the parameters)
- Use Set to track processed message IDs - prevents duplicate annotation creation on re-renders
- crypto.randomUUID() available in modern browsers (no polyfill needed for this project)
- Dependency array includes [messages, addProposedAnnotation] to re-run when messages update
- processedMessageIdsRef persists across renders without triggering re-renders
  </action>
  <verify>
    Send message with canvas screenshot → AI proposes annotation via tool call
    Console.log in useEffect shows part.type === 'tool-call' extracted
    proposedAnnotations state in context updated with new annotation
    Annotation has unique ID, type, text, positionHint fields
    Multiple annotations accumulate in state (don't overwrite)
    Re-renders don't duplicate annotations (processedMessageIds works)
    Fast refresh doesn't create duplicates
    TypeScript has no errors with message.parts access
  </verify>
  <done>AI tool calls extracted from message.parts with duplicate prevention, stored as proposedAnnotations in React context</done>
</task>

<task type="auto">
  <name>Create annotation overlay with smart positioning using viewport bounds</name>
  <files>components/workspace/AnnotationOverlay.tsx, lib/annotation-positioning.ts, components/workspace/CanvasPanel.tsx</files>
  <action>
**Create lib/annotation-positioning.ts:**
Smart positioning algorithm using canvas viewport (not shape bounds - simplified for MVP):

```typescript
import { Editor } from 'tldraw';
import { ProposedAnnotation } from './types/annotations';

export interface AnnotationPosition {
  x: number; // pixels from left (screen coordinates)
  y: number; // pixels from top (screen coordinates)
}

const ANNOTATION_WIDTH = 280; // Estimated card width in pixels
const ANNOTATION_HEIGHT = 120; // Estimated card height in pixels
const PADDING = 20; // Edge padding

/**
 * Calculate annotation position based on positionHint and viewport bounds
 * Uses screen coordinates (CSS pixels) for overlay positioning
 * MVP limitation: Uses viewport bounds, not shape overlap detection
 */
export function calculateAnnotationPosition(
  editor: Editor | null,
  annotation: ProposedAnnotation,
  existingPositions: AnnotationPosition[] = [],
): AnnotationPosition {
  // Fallback if no editor
  if (!editor) {
    return { x: PADDING, y: PADDING };
  }

  const { positionHint = 'top-right' } = annotation;

  // Get viewport bounds (screen space)
  const viewport = editor.getViewportScreenBounds();

  // Calculate preferred position based on hint
  const preferredPosition = getPreferredPosition(positionHint, viewport);

  // Check if preferred position overlaps existing annotations
  if (!overlapsExisting(preferredPosition, existingPositions)) {
    return preferredPosition;
  }

  // Try other corners if preferred is taken
  const fallbackPositions = getAllPositions(viewport).filter(
    pos => !overlapsExisting(pos, existingPositions)
  );

  if (fallbackPositions.length > 0) {
    return fallbackPositions[0];
  }

  // Last resort: stack below last annotation
  if (existingPositions.length > 0) {
    const lastPos = existingPositions[existingPositions.length - 1];
    return { x: lastPos.x, y: lastPos.y + ANNOTATION_HEIGHT + 10 };
  }

  return preferredPosition; // Accept overlap if unavoidable
}

function getPreferredPosition(
  hint: string,
  viewport: { x: number; y: number; w: number; h: number }
): AnnotationPosition {
  const positions: Record<string, AnnotationPosition> = {
    'top-left': {
      x: PADDING,
      y: PADDING
    },
    'top-right': {
      x: viewport.w - ANNOTATION_WIDTH - PADDING,
      y: PADDING
    },
    'bottom-left': {
      x: PADDING,
      y: viewport.h - ANNOTATION_HEIGHT - PADDING
    },
    'bottom-right': {
      x: viewport.w - ANNOTATION_WIDTH - PADDING,
      y: viewport.h - ANNOTATION_HEIGHT - PADDING
    },
    'center': {
      x: (viewport.w - ANNOTATION_WIDTH) / 2,
      y: (viewport.h - ANNOTATION_HEIGHT) / 2
    },
  };

  return positions[hint] || positions['top-right'];
}

function getAllPositions(
  viewport: { x: number; y: number; w: number; h: number }
): AnnotationPosition[] {
  return [
    getPreferredPosition('top-right', viewport),
    getPreferredPosition('top-left', viewport),
    getPreferredPosition('bottom-right', viewport),
    getPreferredPosition('bottom-left', viewport),
  ];
}

function overlapsExisting(
  pos: AnnotationPosition,
  existing: AnnotationPosition[]
): boolean {
  const box = {
    x1: pos.x,
    y1: pos.y,
    x2: pos.x + ANNOTATION_WIDTH,
    y2: pos.y + ANNOTATION_HEIGHT,
  };

  return existing.some(existingPos => {
    const existingBox = {
      x1: existingPos.x,
      y1: existingPos.y,
      x2: existingPos.x + ANNOTATION_WIDTH,
      y2: existingPos.y + ANNOTATION_HEIGHT,
    };

    return !(
      box.x2 < existingBox.x1 ||
      box.x1 > existingBox.x2 ||
      box.y2 < existingBox.y1 ||
      box.y1 > existingBox.y2
    );
  });
}
```

**Create components/workspace/AnnotationOverlay.tsx:**
Render annotations with smart positioning:

```tsx
"use client";

import { useProblem } from '@/lib/problem-context';
import { ProposedAnnotation } from '@/lib/types/annotations';
import { CheckIcon, XIcon } from 'lucide-react';
import { cn } from '@/lib/utils';
import { calculateAnnotationPosition, AnnotationPosition } from '@/lib/annotation-positioning';
import { TldrawEditorRef } from '@/components/TldrawEditor';
import { useMemo } from 'react';

interface AnnotationCardProps {
  annotation: ProposedAnnotation;
  onApprove: (id: string) => void;
  onDismiss: (id: string) => void;
  position: AnnotationPosition;
}

function AnnotationCard({ annotation, onApprove, onDismiss, position }: AnnotationCardProps) {
  const isQuestion = annotation.type === 'question';

  return (
    <div
      className={cn(
        "absolute z-10 w-70 p-4 rounded-lg shadow-lg border-2 backdrop-blur-sm",
        isQuestion
          ? "bg-blue-50/95 border-blue-400"
          : "bg-amber-50/95 border-amber-400"
      )}
      style={{
        left: `${position.x}px`,
        top: `${position.y}px`,
      }}
    >
      <div className="mb-3">
        <span className={cn(
          "text-xs font-semibold uppercase tracking-wide",
          isQuestion ? "text-blue-700" : "text-amber-700"
        )}>
          {isQuestion ? "Question" : "Hint"}
        </span>
        <p className="mt-1 text-sm text-gray-800 leading-relaxed">
          {annotation.text}
        </p>
      </div>

      <div className="flex gap-2">
        <button
          onClick={() => onApprove(annotation.id)}
          className="flex-1 flex items-center justify-center gap-1 px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded transition-colors"
        >
          <CheckIcon className="w-4 h-4" />
          Approve
        </button>
        <button
          onClick={() => onDismiss(annotation.id)}
          className="flex-1 flex items-center justify-center gap-1 px-3 py-1.5 bg-gray-600 hover:bg-gray-700 text-white text-sm font-medium rounded transition-colors"
        >
          <XIcon className="w-4 h-4" />
          Dismiss
        </button>
      </div>
    </div>
  );
}

interface AnnotationOverlayProps {
  editorRef: React.RefObject<TldrawEditorRef>;
}

export function AnnotationOverlay({ editorRef }: AnnotationOverlayProps) {
  const { proposedAnnotations, removeProposedAnnotation } = useProblem();

  const handleApprove = (id: string) => {
    // Will be implemented in next plan (canvas integration)
    console.log('Approve annotation:', id);
    // For now, just remove from proposed list
    removeProposedAnnotation(id);
  };

  const handleDismiss = (id: string) => {
    removeProposedAnnotation(id);
  };

  // Calculate positions for all annotations using smart positioning
  // FIX: Remove editorRef from dependency array - it won't trigger recalculation when editor mounts
  // Rely on proposedAnnotations changes only
  const annotationPositions = useMemo(() => {
    const editor = editorRef.current?.getEditor() || null;
    const positions: AnnotationPosition[] = [];

    proposedAnnotations.forEach(annotation => {
      const position = calculateAnnotationPosition(editor, annotation, positions);
      positions.push(position);
    });

    return positions;
  }, [proposedAnnotations]); // Removed editorRef dependency

  return (
    <>
      {proposedAnnotations.map((annotation, index) => (
        <AnnotationCard
          key={annotation.id}
          annotation={annotation}
          onApprove={handleApprove}
          onDismiss={handleDismiss}
          position={annotationPositions[index]}
        />
      ))}
    </>
  );
}
```

**Update components/workspace/CanvasPanel.tsx:**
Integrate annotation overlay:

```tsx
import { AnnotationOverlay } from './AnnotationOverlay';

// In CanvasPanel component:
return (
  <div className="relative w-full h-full">
    <TldrawEditor ref={editorRef} onChange={handleCanvasChange} />
    <AnnotationOverlay editorRef={editorRef} />
  </div>
);
```

**Implementation notes:**
- Positioning uses viewport bounds (screen coordinates) not canvas page coordinates
- editor.getViewportScreenBounds() returns { x, y, w, h } in screen pixels
- Overlay uses absolute positioning with left/top in pixels
- useMemo recalculates positions when annotations change (NOT when editor changes)
- Positions calculated sequentially to avoid overlaps between multiple annotations
- MVP limitation accepted: viewport bounds only, not shape overlap detection (Success Criterion 4)
- Questions: Blue theme (bg-blue-50/95, border-blue-400)
- Hints: Amber theme (bg-amber-50/95, border-amber-400)
- Semi-transparent with backdrop-blur for visibility over canvas
  </action>
  <verify>
    AI proposes annotation → AnnotationCard appears overlaid on canvas
    Question annotations styled with blue theme
    Hint annotations styled with amber theme
    Annotations positioned according to positionHint (top-right, top-left, etc.)
    Multiple annotations don't overlap (positioning algorithm works)
    Approve button clickable → removes annotation from view (console.log shows ID)
    Dismiss button clickable → removes annotation from view
    Annotations visible above canvas (z-index works)
    Semi-transparent background readable over canvas content
    Viewport resize updates positions (useMemo dependency works)
    Build passes with no TypeScript errors
  </verify>
  <done>Annotations render as overlays with approve/dismiss buttons, distinct question/hint styling, smart positioning using viewport bounds avoiding overlaps</done>
</task>

</tasks>

<verification>
**Annotation overlay:**
1. AI-proposed annotations appear as cards overlaid on canvas
2. Cards include type indicator (Question/Hint), text, approve/dismiss buttons
3. Question annotations: blue theme
4. Hint annotations: amber theme
5. Cards semi-transparent with backdrop blur

**Positioning:**
1. Annotations positioned based on positionHint (top-right, top-left, etc.)
2. Multiple annotations avoid overlapping each other
3. Positioning algorithm uses viewport bounds
4. MVP limitation accepted: Does not query canvas shapes for overlap avoidance
5. Fallback stacking if all corners occupied

**Interactions:**
1. Approve button removes annotation (placeholder for canvas integration)
2. Dismiss button removes annotation completely
3. Buttons respond to clicks with visual feedback

**Tool call extraction:**
1. message.parts array correctly parsed
2. part.type === 'tool-call' detected
3. part.toolName === 'proposeAnnotation' filtered
4. Duplicate prevention via processedMessageIds Set
5. No duplicate annotations on re-render

**Technical checks:**
- Build passes: `npm run build`
- No console errors during annotation rendering
- proposedAnnotations state updates correctly in context
- Tool calls from AI successfully converted to annotation cards
- useMemo prevents unnecessary recalculations

**Requirements coverage:**
- ANNO-03: Approve/dismiss buttons on annotations ✓
- ANNO-04: Smart positioning avoiding overlaps (viewport-based, MVP limitation) ✓
- ANNO-06: Dismiss removes without trace ✓ (partial - full in next plan)
</verification>

<success_criteria>
- [ ] AI tool calls extracted from message.parts array
- [ ] Tool calls filtered by part.type === 'tool-call' and part.toolName
- [ ] Duplicate prevention using processedMessageIds Set
- [ ] Complete dependency array [messages, addProposedAnnotation] specified
- [ ] Annotation cards render overlaid on canvas
- [ ] Question annotations styled with blue theme
- [ ] Hint annotations styled with amber theme
- [ ] Approve and dismiss buttons functional
- [ ] Positioning algorithm uses viewport bounds (MVP approach)
- [ ] useMemo dependency array excludes editorRef (relies on proposedAnnotations only)
- [ ] Multiple annotations avoid overlapping via sequential position calculation
- [ ] Dismiss removes annotation from view immediately
- [ ] Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-guidance-annotations/03-02-SUMMARY.md`
</output>
